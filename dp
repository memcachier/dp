#!/usr/bin/env bash
DP_VERSION=1.0.1

set -e

function runssh() {
  ssh -p $PORT $SSH_ARGS $REMOTE_USER@$REMOTE_HOST $2 "$1"
}

function print_usage() {
    cat <<EOF
MemCachier Daemon Deployment Tool!
Version $DP_VERSION
Usage: `basename $0` [--version] [--help] <command> <args>

Commands are:
  init            Turn current directory into a DP app.
  init-server     Start a new DP install on the remote server.
  deploy          Deploy the latest version of the managed app.
  config          Display app environment.
  config:get      Display a specific app env variable.
  config:set      Set a specific app env variable.
  config:setbulk  Set many app env variables.
  config:unset    Remove a specific app env variable.
  start           Start the app on the remote server.
  stop            Stop the app on the remote server.
  restart         Restart the app on the remote server.
  status          Display running state of the app on the remote server.
  version         Display version of app deployed on remote server.
  logs            Display latest log output of app.
  run             Run a command on the remote server.
EOF
}

# Default settings
PORT=22
BASE_DIR="\$HOME/app"
REMOTE_USER=${REMOTE_USER:-$(whoami)}
LOG_FILES=10
LOG_SIZE=10485760
defaultenv="default"
envdir=${ENV:-$defaultenv}

if [[ $# -eq 0 ]]
then
  print_usage
  exit 1
else
  command=$1
  shift
fi

case "$command" in
  --version)
    echo "DP version ${DP_VERSION}"
    exit 0
    ;;

  --help)
    print_usage
    exit 0
    ;;
  help)
    print_usage
    exit 0
    ;;

  init)
    if [[ -e ".dp/$envdir/config" ]]
    then
      echo ".dp directory already exists!"
      echo "This appears to already be a DP app"
      exit 1
    fi
    mkdir -p .dp/production
    mkdir -p .dp/staging
    ln -s production .dp/default
    cat << EOF > .dp/production/config
# Remote host to run your application
#REMOTE_HOST=...
#REMOTE_USER=...

# Directory to install your app to (Default: \$HOME)
#BASE_DIR=...

# Log management (can't change after setting up server!)
#LOG_FILES=${LOG_FILES}
#LOG_SIZE=${LOG_SIZE}
EOF
  cp .dp/production/config .dp/staging/config
  cat << EOF > .dp/compile
# Place compilation commands here
EOF
    touch Procfile
    echo "Please edit .dp/*/config files now to setup the remote server"
    echo "Please edit Procfile to set app command"
    exit
    ;;
esac

if [[ -e ".dp/$envdir/config" ]]
then
  . ".dp/$envdir/config"
else
  echo "No .dp/$envdir/ directory found"
  echo "Is this a DP managed app?"
  exit 1
fi

if [[ -z "$REMOTE_USER" ]]
then
  echo "REMOTE_USER not set in config file: .dp/$envdir/config"
  exit 1
fi

if [[ -z "$REMOTE_HOST" ]]
then
  echo "REMOTE_HOST not set in config file: .dp/$envdir/config"
  exit 1
fi

envs="cd $BASE_DIR/.envdir && for e in \`ls\`; do echo -n \"\$e=\"; cat \$e; done"

case "$command" in
  version)
    runssh "cat $BASE_DIR/versions/current/.gitversion"
    ;;

  init-server)
    cmd=$(cat <<EOF
mkdir -p $BASE_DIR/versions
mkdir -p $BASE_DIR/.envdir
touch $BASE_DIR/log
cat <<EF > $BASE_DIR/cmd
#!/usr/bin/env bash
cd \\\`dirname \\\$0\\\`/versions/current
IFS="[: ]"
read name cmd < Procfile
echo "Starting \\\$name..."
exec envdir ../../.envdir bash -c "\\\$cmd"
EF
chmod +x $BASE_DIR/cmd
cat <<EF > $BASE_DIR/run
#!/usr/bin/env bash
WHERE=\\\`pwd\\\`
./cmd | multilog s${LOG_SIZE} n${LOG_FILES} \\\$WHERE/logs
EF
chmod +x $BASE_DIR/run
ln -s $BASE_DIR/logs/current log
EOF
)
    runssh "$cmd"
    ;;

  config)
    runssh "$envs"
    ;;

  config:get)
    runssh "cat $BASE_DIR/.envdir/$1"
    ;;

  config:set)
    IFS="="
    read key value <<< "$1"
    cmd="mkdir -p $BASE_DIR/.envdir && echo \"$value\" > $BASE_DIR/.envdir/$key"
    runssh "$cmd"
    ;;

  config:setbulk)
    cmd="mkdir -p $BASE_DIR/.envdir"
    IFS="="
    while read key value
    do
      cmd="$cmd; echo \"$value\" > $BASE_DIR/.envdir/$key"
    done
    runssh "$cmd"
    ;;

  config:unset) runssh "rm -f $BASE_DIR/.envdir/$1"
    ;;

  run) runssh "cd $BASE_DIR/versions/current && envdir ../../.envdir bash -c \"$*\"" "-t"
    ;;

  logs)
    args="-n 100 $*"
    runssh "tail $args $BASE_DIR/log"
    ;;

  status) runssh "cd $BASE_DIR && svstat ."
    ;;

  stop)
    echo "Stopping app..."
    runssh "svc -d $BASE_DIR"
    ;;

  start)
    echo "Starting app..."
    cmd=$(cat <<EOF
svok $BASE_DIR
if [[ \$? -gt 0 ]]
then
  start-stop-daemon --no-close --background -m \
    --pidfile $BASE_DIR/pid --start \
    --startas \`which supervise\` \
    -- $BASE_DIR &>> $BASE_DIR/supervise.log
else
  svc -u $BASE_DIR
fi
EOF
)
    runssh "$cmd"
    ;;

  restart)
    echo "Restarting app..."
    runssh "svc -d $BASE_DIR && svc -u $BASE_DIR"
    ;;

  deploy)
    [[ $# -gt 0 ]] && branch=$1 || branch=master
    githash=`git show-ref -s refs/heads/$branch`
    cmds=$(cat <<EOF 
set -e
cat > /tmp/app.tar;
export BASE_DIR=$BASE_DIR
export DIST_DIR=$BASE_DIR/versions/\`date -u +%Y%m%d%H%M\`
mkdir -p \$DIST_DIR
echo "Extracting app"
tar xf /tmp/app.tar -C \$DIST_DIR
cd \$DIST_DIR
echo $githash > .gitversion
echo "Compiling..."

`cat .dp/compile`

rm -f \$DIST_DIR/../current
ln -s \$DIST_DIR \$DIST_DIR/../current
EOF
)

    # Git archive doesn't support submodules, so we re-implement ourselves.
    # This works well, but sadly we loose support for the gitattributes
    # 'export-ignore' attribute.
    { git ls-files;
      git submodule foreach --quiet --recursive \
        'cd $toplevel; cd $name; 
         git ls-files --with-tree="$sha1" | sed "s#^#$toplevel/$name/#"'
    } \
      | sed "s#$(pwd)/##" \
      | xargs tar -c -f - --no-recursion -- \
      | runssh "$cmds"
    ;;

  *)
    echo "Unknown command!"
    exit 1
    ;;

esac

