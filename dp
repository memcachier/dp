#!/usr/bin/env bash
DP_VERSION=0.1

set -e

function runssh() {
  ssh -p $PORT $SSH_ARGS $REMOTE_USER@$REMOTE_HOST $2 "$1"
}

# Default settings
PORT=22
BASE_DIR="\$HOME/app"
REMOTE_USER=${REMOTE_USER:-$(whoami)}
defaultenv="default"
envdir=${ENV:-$defaultenv}

if [[ $# -eq 0 ]]
then
  command="help"
else
  command=$1
  shift
fi

if [[ -e ".dp/$envdir/config" ]]
then
  . ".dp/$envdir/config"
else
  if [[ $command != "help" && $command != "init" ]]
  then
    echo "No .dp/$envdir/ directory found"
    echo "Is this a DP managed app?"
    exit 1
  fi
fi

envs="cd $BASE_DIR/.envdir && for e in \`ls\`; do echo -n \"\$e=\"; cat \$e; done"

case "$command" in
  help)
    cat <<EOF
MemCachier Daemon Deployment Tool!
Version $DP_VERSION
Usage: `basename $0` <command> <args>

Commands are:
  init          Turn current directory into a DP app.
  init-server   Start a new DP install on the remote server.
  deploy        Deploy the latest version of the managed app.
  config[:get | :set | :setbulk | :unset]
  start         Start the app on the remote server.
  stop          Stop the app on the remote server.
  restart       Restart the app on the remote server.
  status        Display running state of the app on the remote server.
  version       Display version of app deployed on remote server.
  logs          Display latest log output of app.
  run           Run a command on the remote server.
EOF
    ;;
  version) runssh "cat $BASE_DIR/versions/current/.gitversion"
    ;;
  init)
if [[ -e ".dp/$envdir/config" ]]
then
  echo ".dp directory already exists!"
  echo "This appears to already be a DP app"
  exit 1
fi
mkdir -p .dp/production
mkdir -p .dp/staging
ln -s production .dp/default
cat << EOF > .dp/production/config
# Please fill in with appropriate host.
#REMOTE_HOST=...
#REMOTE_USER=...
EOF
cp .dp/production/config .dp/staging/config
cat << EOF > .dp/compile
# Place compilation commands here
EOF
    ;;
  init-server)
    cmd=$(cat <<EOF
mkdir -p $BASE_DIR/versions
mkdir -p $BASE_DIR/.envdir
touch $BASE_DIR/log
cat <<EF > $BASE_DIR/run
#!/usr/bin/env bash
cd \\\`dirname \\\$0\\\`/versions/current
IFS="[: ]"
read name cmd < Procfile
echo "Starting \\\$name..."
exec envdir ../../.envdir \\\$cmd
EF
chmod +x $BASE_DIR/run
EOF
)
    runssh "$cmd"
    ;;
  config) runssh "$envs"
    ;;
  config:get)
    runssh "cat $BASE_DIR/.envdir/$1"
    ;;
  config:set)
    IFS="="
    read key value <<< "$1"
    cmd="mkdir -p $BASE_DIR/.envdir && echo \"$value\" > $BASE_DIR/.envdir/$key"
    runssh "$cmd"
    ;;
  config:setbulk)
    cmd="mkdir -p $BASE_DIR/.envdir"
    IFS="="
    while read key value
    do
      cmd="$cmd; echo \"$value\" > $BASE_DIR/.envdir/$key"
    done
    runssh "$cmd"
    ;;
  config:unset) runssh "rm -f $BASE_DIR/.envdir/$1"
    ;;
  run) runssh "cd $BASE_DIR/versions/current && envdir ../../.envdir bash -c \"$*\"" "-t"
    ;;
  logs)
    args="-n 100 $*"
    runssh "tail $args $BASE_DIR/log"
    ;;
  status) runssh "cd $BASE_DIR && svstat ."
    ;;
  stop)
    echo "Stopping app..."
    runssh "svc -d $BASE_DIR"
    ;;
  start)
    echo "Starting app..."
    cmd=$(cat <<EOF
svok $BASE_DIR
if [[ \$? -gt 0 ]]
then
  start-stop-daemon --no-close --background -m --pidfile $BASE_DIR/pid --start --startas \`which supervise\` -- $BASE_DIR &>> $BASE_DIR/log
else
  svc -u $BASE_DIR
fi
EOF
)
    runssh "$cmd"
    ;;
  restart)
    echo "Restarting app..."
    runssh "svc -d $BASE_DIR && svc -u $BASE_DIR"
    ;;
  deploy)

    [[ $# -gt 0 ]] && branch=$1 || branch=master
    githash=`git show-ref -s refs/heads/$branch`
    cmds=$(cat <<EOF 
set -e
cat > /tmp/app.tar;
export BASE_DIR=$BASE_DIR
export DIST_DIR=$BASE_DIR/versions/\`date -u +%Y%m%d%H%M\`
mkdir -p \$DIST_DIR
echo "Extracting app"
tar xf /tmp/app.tar -C \$DIST_DIR
cd \$DIST_DIR
echo $githash > .gitversion
echo "Compiling..."

`cat .dp/compile`

rm -f \$DIST_DIR/../current
ln -s \$DIST_DIR \$DIST_DIR/../current
EOF
)
    git archive $branch . | runssh "$cmds"
    ;;
esac

